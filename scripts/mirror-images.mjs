// scripts/mirror-images.mjs
// Mirrors remote image URLs into ./public so deployments are stable.
// - Reads image-sources.json
// - Downloads into ./public/renderings and ./public/history
// - Generates ./src/components/imageManifest.ts used by the site

import fs from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();
const SOURCES_PATH = path.join(ROOT, 'image-sources.json');

const RENDERINGS_DIR = path.join(ROOT, 'public', 'renderings');
const HISTORY_DIR = path.join(ROOT, 'public', 'history');
const MANIFEST_PATH = path.join(ROOT, 'src', 'components', 'imageManifest.ts');

// Tunables (safe defaults for CI/CD environments like Vercel)
const TIMEOUT_MS = 20_000;
const MAX_CONCURRENCY = 3;
const RETRIES = 2;

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    return await fetch(url, {
      redirect: 'follow',
      signal: controller.signal,
      headers: {
        // Some hosts behave better if you look like a browser.
        'User-Agent': 'Mozilla/5.0 (compatible; EnggrassLoftsBot/1.0; +https://vercel.com)',
        Accept: 'image/avif,image/webp,image/apng,image/*,*/*;q=0.8',
      },
    });
  } finally {
    clearTimeout(t);
  }
}

async function download(url, destPath) {
  for (let attempt = 0; attempt <= RETRIES; attempt++) {
    try {
      const res = await fetchWithTimeout(url, TIMEOUT_MS);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const buf = Buffer.from(await res.arrayBuffer());
      fs.writeFileSync(destPath, buf);
      return;
    } catch (e) {
      const last = attempt === RETRIES;
      console.warn(
        `[mirror-images] ${last ? 'FAILED' : 'retrying'} (${attempt + 1}/${RETRIES + 1}) ${url}: ${e?.message || e}`
      );
      if (last) return; // don't fail the build; just skip
      await sleep(750 * (attempt + 1));
    }
  }
}

function listImageFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  const exts = new Set(['.jpg', '.jpeg', '.png', '.webp', '.gif']);
  return fs
    .readdirSync(dir)
    .filter((f) => exts.has(path.extname(f).toLowerCase()))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
}

function writeManifest({ renderings, history, labelsByFile }) {
  const serializeItems = (files) =>
    files
      .map((file) => {
        const label = labelsByFile.get(file);
        return label
          ? `  { file: ${JSON.stringify(file)}, label: ${JSON.stringify(label)} },`
          : `  { file: ${JSON.stringify(file)} },`;
      })
      .join('\n');

  const contents = `// AUTO-GENERATED by scripts/mirror-images.mjs\n// Do not edit manually. Update image-sources.json instead.\n\nexport type ManifestItem = { file: string; label?: string };\n\nexport const renderingFiles: ManifestItem[] = [\n${serializeItems(renderings)}\n];\n\nexport const historyFiles: ManifestItem[] = [\n${serializeItems(history)}\n];\n`;

  fs.writeFileSync(MANIFEST_PATH, contents, 'utf8');
}

async function runQueue(tasks, maxConcurrency) {
  let i = 0;
  const workers = Array.from({ length: maxConcurrency }, async () => {
    while (i < tasks.length) {
      const idx = i++;
      await tasks[idx]();
    }
  });
  await Promise.all(workers);
}

async function main() {
  ensureDir(RENDERINGS_DIR);
  ensureDir(HISTORY_DIR);

  const labelsByFile = new Map();
  let sources = { history: [], renderings: [] };

  if (fs.existsSync(SOURCES_PATH)) {
    sources = JSON.parse(fs.readFileSync(SOURCES_PATH, 'utf8'));
  }

  const tasks = [];

  for (const item of sources.renderings || []) {
    const filename = item.filename || path.basename(new URL(item.url).pathname);
    const dest = path.join(RENDERINGS_DIR, filename);
    if (item.label) labelsByFile.set(filename, item.label);
    if (!fs.existsSync(dest)) {
      tasks.push(async () => {
        console.log(`[mirror-images] downloading renderings/${filename}`);
        await download(item.url, dest);
      });
    }
  }

  for (const item of sources.history || []) {
    const filename = item.filename || path.basename(new URL(item.url).pathname);
    const dest = path.join(HISTORY_DIR, filename);
    if (item.label) labelsByFile.set(filename, item.label);
    if (!fs.existsSync(dest)) {
      tasks.push(async () => {
        console.log(`[mirror-images] downloading history/${filename}`);
        await download(item.url, dest);
      });
    }
  }

  if (tasks.length) {
    console.log(`[mirror-images] Downloading ${tasks.length} image(s)...`);
    await runQueue(tasks, MAX_CONCURRENCY);
  } else {
    console.log('[mirror-images] No downloads needed.');
  }

  const renderingFiles = listImageFiles(RENDERINGS_DIR);
  const historyFiles = listImageFiles(HISTORY_DIR);

  writeManifest({ renderings: renderingFiles, history: historyFiles, labelsByFile });

  console.log(
    `[mirror-images] Wrote src/components/imageManifest.ts with ${renderingFiles.length} rendering(s) and ${historyFiles.length} history image(s).`
  );
}

main().catch((e) => {
  console.error('[mirror-images] Fatal error:', e);
  process.exit(1);
});
