import fs from 'node:fs';
import path from 'node:path';
import https from 'node:https';

const ROOT = process.cwd();
const SOURCES_PATH = path.join(ROOT, 'image-sources.json');

/**
 * This script mirrors remote image URLs into the repo so deployments are stable.
 *
 * - Reads image-sources.json
 * - Downloads images into ./renderings and ./history (project-root folders)
 * - Generates ./components/imageManifest.ts used by pages at build time
 *
 * Runs automatically on `npm run build` via the `prebuild` script.
 */

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function download(url, destPath) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(destPath);

    const request = https.get(url, (res) => {
      // Handle redirects
      if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        file.close();
        fs.unlinkSync(destPath);
        return resolve(download(res.headers.location, destPath));
      }

      if (res.statusCode !== 200) {
        file.close();
        try { fs.unlinkSync(destPath); } catch {}
        return reject(new Error(`HTTP ${res.statusCode} for ${url}`));
      }

      res.pipe(file);
      file.on('finish', () => file.close(resolve));
    });

    request.on('error', (err) => {
      file.close();
      try { fs.unlinkSync(destPath); } catch {}
      reject(err);
    });
  });
}

function listImageFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  const exts = new Set(['.jpg', '.jpeg', '.png', '.webp', '.gif']);
  return fs
    .readdirSync(dir)
    .filter((f) => exts.has(path.extname(f).toLowerCase()))
    .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
}

function writeManifest({ renderings, history, labelsByFile }) {
  const outPath = path.join(ROOT, 'components', 'imageManifest.ts');

  const serializeItems = (files) =>
    files
      .map((file) => {
        const label = labelsByFile.get(file);
        return label
          ? `  { file: ${JSON.stringify(file)}, label: ${JSON.stringify(label)} },`
          : `  { file: ${JSON.stringify(file)} },`;
      })
      .join('\n');

  const contents = `// AUTO-GENERATED by scripts/mirror-images.mjs\n// Do not edit manually. Update image-sources.json instead.\n\nexport type ManifestItem = { file: string; label?: string };\n\nexport const renderingFiles: ManifestItem[] = [\n${serializeItems(renderings)}\n];\n\nexport const historyFiles: ManifestItem[] = [\n${serializeItems(history)}\n];\n`;

  fs.writeFileSync(outPath, contents, 'utf8');
}

async function main() {
  // Always generate a manifest, even if image-sources.json is missing.
  const renderingsDir = path.join(ROOT, 'renderings');
  const historyDir = path.join(ROOT, 'history');
  ensureDir(renderingsDir);
  ensureDir(historyDir);

  const labelsByFile = new Map();
  let sources = { history: [], renderings: [] };

  if (fs.existsSync(SOURCES_PATH)) {
    sources = JSON.parse(fs.readFileSync(SOURCES_PATH, 'utf8'));
  }

  const jobs = [];

  for (const item of sources.renderings || []) {
    const filename = item.filename || path.basename(new URL(item.url).pathname);
    const dest = path.join(renderingsDir, filename);
    if (item.label) labelsByFile.set(filename, item.label);
    if (!fs.existsSync(dest)) jobs.push(download(item.url, dest).catch((e) => {
      console.warn(`[mirror-images] Failed to download ${item.url}: ${e.message}`);
    }));
  }

  for (const item of sources.history || []) {
    const filename = item.filename || path.basename(new URL(item.url).pathname);
    const dest = path.join(historyDir, filename);
    if (item.label) labelsByFile.set(filename, item.label);
    if (!fs.existsSync(dest)) jobs.push(download(item.url, dest).catch((e) => {
      console.warn(`[mirror-images] Failed to download ${item.url}: ${e.message}`);
    }));
  }

  if (jobs.length) {
    console.log(`[mirror-images] Downloading ${jobs.length} image(s)...`);
    await Promise.all(jobs);
  } else {
    console.log('[mirror-images] No downloads needed.');
  }

  // Include everything that exists locally (including any hand-added files).
  const renderingFiles = listImageFiles(renderingsDir);
  const historyFiles = listImageFiles(historyDir);

  writeManifest({
    renderings: renderingFiles,
    history: historyFiles,
    labelsByFile,
  });

  console.log(`[mirror-images] Wrote components/imageManifest.ts with ${renderingFiles.length} rendering(s) and ${historyFiles.length} history image(s).`);
}

main().catch((e) => {
  console.error('[mirror-images] Fatal error:', e);
  process.exit(1);
});
